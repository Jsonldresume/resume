{"ast":null,"code":"'use strict';\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js');\n\nvar factorySpace = require('./factory-space.js');\n\nvar shallow = require('../util/shallow.js');\n\nvar setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n};\n\nfunction resolveToSetextUnderline(events, context) {\n  var index = events.length;\n  var content;\n  var text;\n  var definition;\n  var heading; // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index;\n        break;\n      }\n\n      if (events[index][1].type === 'paragraph') {\n        text = index;\n      }\n    } // Exit\n    else {\n        if (events[index][1].type === 'content') {\n          // Remove the content end (if needed we’ll add it later)\n          events.splice(index, 1);\n        }\n\n        if (!definition && events[index][1].type === 'definition') {\n          definition = index;\n        }\n      }\n  }\n\n  heading = {\n    type: 'setextHeading',\n    start: shallow(events[text][1].start),\n    end: shallow(events[events.length - 1][1].end)\n  }; // Change the paragraph to setext heading text.\n\n  events[text][1].type = 'setextHeadingText'; // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context]);\n    events.splice(definition + 1, 0, ['exit', events[content][1], context]);\n    events[content][1].end = shallow(events[definition][1].end);\n  } else {\n    events[content][1] = heading;\n  } // Add the heading exit at the end.\n\n\n  events.push(['exit', heading, context]);\n  return events;\n}\n\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  var self = this;\n  var index = self.events.length;\n  var marker;\n  var paragraph; // Find an opening.\n\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (self.events[index][1].type !== 'lineEnding' && self.events[index][1].type !== 'linePrefix' && self.events[index][1].type !== 'content') {\n      paragraph = self.events[index][1].type === 'paragraph';\n      break;\n    }\n  }\n\n  return start;\n\n  function start(code) {\n    if (!self.lazy && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine');\n      effects.enter('setextHeadingLineSequence');\n      marker = code;\n      return closingSequence(code);\n    }\n\n    return nok(code);\n  }\n\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code);\n      return closingSequence;\n    }\n\n    effects.exit('setextHeadingLineSequence');\n    return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code);\n  }\n\n  function closingSequenceEnd(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine');\n      return ok(code);\n    }\n\n    return nok(code);\n  }\n}\n\nmodule.exports = setextUnderline;","map":{"version":3,"sources":["D:/github/jsonldresume/my-app/node_modules/micromark/dist/tokenize/setext-underline.js"],"names":["markdownLineEnding","require","factorySpace","shallow","setextUnderline","name","tokenize","tokenizeSetextUnderline","resolveTo","resolveToSetextUnderline","events","context","index","length","content","text","definition","heading","type","splice","start","end","push","effects","ok","nok","self","marker","paragraph","code","lazy","interrupt","enter","closingSequence","consume","exit","closingSequenceEnd","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nvar markdownLineEnding = require('../character/markdown-line-ending.js')\nvar factorySpace = require('./factory-space.js')\nvar shallow = require('../util/shallow.js')\n\nvar setextUnderline = {\n  name: 'setextUnderline',\n  tokenize: tokenizeSetextUnderline,\n  resolveTo: resolveToSetextUnderline\n}\n\nfunction resolveToSetextUnderline(events, context) {\n  var index = events.length\n  var content\n  var text\n  var definition\n  var heading // Find the opening of the content.\n  // It’ll always exist: we don’t tokenize if it isn’t there.\n\n  while (index--) {\n    if (events[index][0] === 'enter') {\n      if (events[index][1].type === 'content') {\n        content = index\n        break\n      }\n\n      if (events[index][1].type === 'paragraph') {\n        text = index\n      }\n    } // Exit\n    else {\n      if (events[index][1].type === 'content') {\n        // Remove the content end (if needed we’ll add it later)\n        events.splice(index, 1)\n      }\n\n      if (!definition && events[index][1].type === 'definition') {\n        definition = index\n      }\n    }\n  }\n\n  heading = {\n    type: 'setextHeading',\n    start: shallow(events[text][1].start),\n    end: shallow(events[events.length - 1][1].end)\n  } // Change the paragraph to setext heading text.\n\n  events[text][1].type = 'setextHeadingText' // If we have definitions in the content, we’ll keep on having content,\n  // but we need move it.\n\n  if (definition) {\n    events.splice(text, 0, ['enter', heading, context])\n    events.splice(definition + 1, 0, ['exit', events[content][1], context])\n    events[content][1].end = shallow(events[definition][1].end)\n  } else {\n    events[content][1] = heading\n  } // Add the heading exit at the end.\n\n  events.push(['exit', heading, context])\n  return events\n}\n\nfunction tokenizeSetextUnderline(effects, ok, nok) {\n  var self = this\n  var index = self.events.length\n  var marker\n  var paragraph // Find an opening.\n\n  while (index--) {\n    // Skip enter/exit of line ending, line prefix, and content.\n    // We can now either have a definition or a paragraph.\n    if (\n      self.events[index][1].type !== 'lineEnding' &&\n      self.events[index][1].type !== 'linePrefix' &&\n      self.events[index][1].type !== 'content'\n    ) {\n      paragraph = self.events[index][1].type === 'paragraph'\n      break\n    }\n  }\n\n  return start\n\n  function start(code) {\n    if (!self.lazy && (self.interrupt || paragraph)) {\n      effects.enter('setextHeadingLine')\n      effects.enter('setextHeadingLineSequence')\n      marker = code\n      return closingSequence(code)\n    }\n\n    return nok(code)\n  }\n\n  function closingSequence(code) {\n    if (code === marker) {\n      effects.consume(code)\n      return closingSequence\n    }\n\n    effects.exit('setextHeadingLineSequence')\n    return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code)\n  }\n\n  function closingSequenceEnd(code) {\n    if (code === null || markdownLineEnding(code)) {\n      effects.exit('setextHeadingLine')\n      return ok(code)\n    }\n\n    return nok(code)\n  }\n}\n\nmodule.exports = setextUnderline\n"]},"metadata":{},"sourceType":"script"}