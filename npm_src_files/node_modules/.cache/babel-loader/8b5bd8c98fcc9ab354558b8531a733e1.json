{"ast":null,"code":"'use strict';\n\nvar slice = [].slice;\nmodule.exports = wrap; // Wrap `fn`.\n// Can be sync or async; return a promise, receive a completion handler, return\n// new values and errors.\n\nfunction wrap(fn, callback) {\n  var invoked;\n  return wrapped;\n\n  function wrapped() {\n    var params = slice.call(arguments, 0);\n    var callback = fn.length > params.length;\n    var result;\n\n    if (callback) {\n      params.push(done);\n    }\n\n    try {\n      result = fn.apply(null, params);\n    } catch (error) {\n      // Well, this is quite the pickle.\n      // `fn` received a callback and invoked it (thus continuing the pipeline),\n      // but later also threw an error.\n      // We’re not about to restart the pipeline again, so the only thing left\n      // to do is to throw the thing instead.\n      if (callback && invoked) {\n        throw error;\n      }\n\n      return done(error);\n    }\n\n    if (!callback) {\n      if (result && typeof result.then === 'function') {\n        result.then(then, done);\n      } else if (result instanceof Error) {\n        done(result);\n      } else {\n        then(result);\n      }\n    }\n  } // Invoke `next`, only once.\n\n\n  function done() {\n    if (!invoked) {\n      invoked = true;\n      callback.apply(null, arguments);\n    }\n  } // Invoke `done` with one value.\n  // Tracks if an error is passed, too.\n\n\n  function then(value) {\n    done(null, value);\n  }\n}","map":{"version":3,"sources":["D:/github/jsonldresume/my-app/node_modules/trough/wrap.js"],"names":["slice","module","exports","wrap","fn","callback","invoked","wrapped","params","call","arguments","length","result","push","done","apply","error","then","Error","value"],"mappings":"AAAA;;AAEA,IAAIA,KAAK,GAAG,GAAGA,KAAf;AAEAC,MAAM,CAACC,OAAP,GAAiBC,IAAjB,C,CAEA;AACA;AACA;;AACA,SAASA,IAAT,CAAcC,EAAd,EAAkBC,QAAlB,EAA4B;AAC1B,MAAIC,OAAJ;AAEA,SAAOC,OAAP;;AAEA,WAASA,OAAT,GAAmB;AACjB,QAAIC,MAAM,GAAGR,KAAK,CAACS,IAAN,CAAWC,SAAX,EAAsB,CAAtB,CAAb;AACA,QAAIL,QAAQ,GAAGD,EAAE,CAACO,MAAH,GAAYH,MAAM,CAACG,MAAlC;AACA,QAAIC,MAAJ;;AAEA,QAAIP,QAAJ,EAAc;AACZG,MAAAA,MAAM,CAACK,IAAP,CAAYC,IAAZ;AACD;;AAED,QAAI;AACFF,MAAAA,MAAM,GAAGR,EAAE,CAACW,KAAH,CAAS,IAAT,EAAeP,MAAf,CAAT;AACD,KAFD,CAEE,OAAOQ,KAAP,EAAc;AACd;AACA;AACA;AACA;AACA;AACA,UAAIX,QAAQ,IAAIC,OAAhB,EAAyB;AACvB,cAAMU,KAAN;AACD;;AAED,aAAOF,IAAI,CAACE,KAAD,CAAX;AACD;;AAED,QAAI,CAACX,QAAL,EAAe;AACb,UAAIO,MAAM,IAAI,OAAOA,MAAM,CAACK,IAAd,KAAuB,UAArC,EAAiD;AAC/CL,QAAAA,MAAM,CAACK,IAAP,CAAYA,IAAZ,EAAkBH,IAAlB;AACD,OAFD,MAEO,IAAIF,MAAM,YAAYM,KAAtB,EAA6B;AAClCJ,QAAAA,IAAI,CAACF,MAAD,CAAJ;AACD,OAFM,MAEA;AACLK,QAAAA,IAAI,CAACL,MAAD,CAAJ;AACD;AACF;AACF,GAtCyB,CAwC1B;;;AACA,WAASE,IAAT,GAAgB;AACd,QAAI,CAACR,OAAL,EAAc;AACZA,MAAAA,OAAO,GAAG,IAAV;AAEAD,MAAAA,QAAQ,CAACU,KAAT,CAAe,IAAf,EAAqBL,SAArB;AACD;AACF,GA/CyB,CAiD1B;AACA;;;AACA,WAASO,IAAT,CAAcE,KAAd,EAAqB;AACnBL,IAAAA,IAAI,CAAC,IAAD,EAAOK,KAAP,CAAJ;AACD;AACF","sourcesContent":["'use strict'\n\nvar slice = [].slice\n\nmodule.exports = wrap\n\n// Wrap `fn`.\n// Can be sync or async; return a promise, receive a completion handler, return\n// new values and errors.\nfunction wrap(fn, callback) {\n  var invoked\n\n  return wrapped\n\n  function wrapped() {\n    var params = slice.call(arguments, 0)\n    var callback = fn.length > params.length\n    var result\n\n    if (callback) {\n      params.push(done)\n    }\n\n    try {\n      result = fn.apply(null, params)\n    } catch (error) {\n      // Well, this is quite the pickle.\n      // `fn` received a callback and invoked it (thus continuing the pipeline),\n      // but later also threw an error.\n      // We’re not about to restart the pipeline again, so the only thing left\n      // to do is to throw the thing instead.\n      if (callback && invoked) {\n        throw error\n      }\n\n      return done(error)\n    }\n\n    if (!callback) {\n      if (result && typeof result.then === 'function') {\n        result.then(then, done)\n      } else if (result instanceof Error) {\n        done(result)\n      } else {\n        then(result)\n      }\n    }\n  }\n\n  // Invoke `next`, only once.\n  function done() {\n    if (!invoked) {\n      invoked = true\n\n      callback.apply(null, arguments)\n    }\n  }\n\n  // Invoke `done` with one value.\n  // Tracks if an error is passed, too.\n  function then(value) {\n    done(null, value)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}